// generateAliceCommitment.ts
import { Barretenberg, Fr } from "@aztec/bb.js";
import { Base8, mulPointEscalar } from "@zk-kit/baby-jubjub";
import { ethers } from "ethers";
import { fileURLToPath } from "url";
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

import fs from "fs";
import path from "path";

const circuit = JSON.parse(
  fs.readFileSync(
    path.resolve(__dirname, "../../Circuits-Noir/target/circuit_alice.json"),
    "utf8"
  )
);
export function derivePublicKey(privateKeyHex: string) {
  const privateKey = BigInt(privateKeyHex);
  const publicKey = mulPointEscalar(Base8, privateKey);
  return {
    x: `0x${publicKey[0].toString(16)}`,
    y: `0x${publicKey[1].toString(16)}`,
  };
}
export default async function generateAliceCommitment(): Promise<string> {
  // Initialize Barretenberg
  const bb = await Barretenberg.new();

  const aliceKey = "0x12345";
  const bobSk = "0x67890";
  const hash_lock_nonce = "0xabcde"; //random val generated by alice
  const order_id = "0xbacef"; //Not sure how order id is generated from the diagram so assuming random generation through UI for now
  const order_id_fr = new Fr(BigInt(order_id));

  const bobPk = derivePublicKey(bobSk);

  const alice_sk = BigInt(aliceKey);
  const bob_pk_point: [bigint, bigint] = [BigInt(bobPk.x), BigInt(bobPk.y)];
  const hash_lock_nonce_bg = BigInt(hash_lock_nonce);

  try {
    // Alice uses her private key and Bob's public key to get the shared secret
    const shared_secret = mulPointEscalar(bob_pk_point, alice_sk);
    const shared_secret_x = shared_secret[0];

    // The hash lock is constructed using Bob's public key
    const bob_pk_x_fr = new Fr(bob_pk_point[0]);
    const hash_lock_nonce_fr = new Fr(hash_lock_nonce_bg);

    //bob_pk_x_fr SHOULD BE enough because noir internal function takes x only not both x and y
    const reconstructed_hash_lock_fr = await bb.poseidon2Hash([
      bob_pk_x_fr,
      hash_lock_nonce_fr,
    ]);

    const shared_secret_x_fr = new Fr(shared_secret_x);

    const computed_nullifier_fr = await bb.poseidon2Hash([
      shared_secret_x_fr,
      bob_pk_x_fr,
      order_id_fr,
    ]);

    const derived_commitment_fr: Fr = await bb.poseidon2Hash([
      reconstructed_hash_lock_fr,
      shared_secret_x_fr,
    ]);

    const result = ethers.AbiCoder.defaultAbiCoder().encode(
      ["bytes32", "bytes32", "bytes32", "bytes32", "bytes32"],
      [
        derived_commitment_fr.toBuffer(),
        hash_lock_nonce_fr.toBuffer(),
        reconstructed_hash_lock_fr.toBuffer(),
        order_id_fr.toBuffer(),
        computed_nullifier_fr.toBuffer(), //passing this just to check if generated correctly or 0 in foundry
      ]
    );
    return result;
  } catch (error) {
    console.log(error);
    throw error;
  } finally {
    // cleanup
    await bb.destroy();
  }
}

(async () => {
  generateAliceCommitment()
    .then((result) => {
      process.stdout.write(result);
      process.exit(0);
    })
    .catch((error) => {
      console.error(error);
      process.exit(1);
    });
})();
